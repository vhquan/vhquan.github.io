<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-08-18 Sun 12:20 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Message Queue</title>
<meta name="author" content="devlift" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="https://vhquan.github.io/css/style.css" type="text/css"/>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="/"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">Message Queue</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orga5db331">1. Concepts</a></li>
<li><a href="#org4491e11">2. Design user interface when MQ is involved</a></li>
<li><a href="#orgb2d3729">3. The role of message queuing in a microservice architecture</a></li>
<li><a href="#org675a137">4. Message Broker - RabbitMQ</a></li>
</ul>
</div>
</div>
<div id="outline-container-orga5db331" class="outline-2">
<h2 id="orga5db331"><span class="section-number-2">1.</span> Concepts</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>Message queuing makes it possible for applications to communicate
asynchronously, by sending messages to each other via a queue. A message
queue provides temporary storage between the sender and the receiver so that
the sender can keep operating without interruption when the destination
program is busy or not connected. <b>Asynchronous processing</b> allows a task to
call a service, and <i>move on to the next task</i> while the service processes the
request at its own pace.</li>
<li>A <b>queue</b> is a line of things waiting to be handled - in sequential order
starting at the beginning of the line. A <b>message queue</b> is a queue of
messages sent between applications. It includes a sequence of work objects
that are waiting to be processed.</li>
<li>A <b>message</b> is the data transported between the sender and the receiver
applications; it's essentially a byte array with some headers on top. An
example of a message could be an event. One application tells another
application to start processing a specific task via the queue.</li>
<li>The basic architecture of a <b>message queue</b> is simple; there are client
applications called <b>producers</b> that create meessages and deliver them to the
message queue. Another application, called a <b>consumer</b>, connects to the queue
and gets the messages to be processed. Messages placed onto the queue are
stored until the consumer retrieves them.</li>
<li>The queue can provide protection from service outages and failures.</li>
<li>Example of queues: Kafka, Heron, real-time streaming, Amazon SQS, and
RabbitMQ.</li>
</ul>


<div id="orgafb5dcc" class="figure">
<p><img src="../images/mq.jpeg" alt="mq.jpeg" />
</p>
</div>
</div>
</div>

<div id="outline-container-org4491e11" class="outline-2">
<h2 id="org4491e11"><span class="section-number-2">2.</span> Design user interface when MQ is involved</h2>
<div class="outline-text-2" id="text-2">
<p>
Dividing work between off-line work handled by a consumer and in-line work
done by the web application depends entirely on the interface you are exposing
to your users. Generally, you'll either:
</p>

<ul class="org-ul">
<li>Perform almost no work in the consumer (merely scheduling a task) and inform
your user that the task will occur offline, usually with a polling mechanism
to update the interface once the task is complete (for example, provisioning
a new VM on Slicehost follows this pattern), or</li>
<li>perform enough work in-line to make it appear to the user that the task has
completed, and tie up hanging ends afterward (posting a message on Twitter
or Facebook likely follow this pattern by updating the tweet/message in your
timeline but updating your followers's timelines out of the band; it's
simple isn't feasible to update all the followers for a Scobleizer in
real-time).</li>
</ul>
</div>
</div>

<div id="outline-container-orgb2d3729" class="outline-2">
<h2 id="orgb2d3729"><span class="section-number-2">3.</span> The role of message queuing in a microservice architecture</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>In a microservice architecture, there are different functionalities divided
across different services, that offer various functionalities. These
services are coupled together to form a complete software application.</li>
<li>Typically, in a microservice architecture, there are cross-dependencies,
which entail that no single service can perform its functionalities without
getting help from other services. <b>This is where it's crucial for your
system to have a mechanism in place which allows services to keep in touch
with each other without getting blocked by responses</b>.</li>
<li>Message queuing fulfills this purpose by providing a means for services to
push messages to a queue asynchronously and ensure that they get delivered
to the correct destination. To implement a message queue between services,
you need a <b>message broker, think of it as a mailman</b>, who takes mail from a
sender and delivers it to the correct destination.</li>
</ul>
</div>
</div>
<div id="outline-container-org675a137" class="outline-2">
<h2 id="org675a137"><span class="section-number-2">4.</span> Message Broker - RabbitMQ</h2>
<div class="outline-text-2" id="text-4">

<div id="orgea4d75e" class="figure">
<p><img src="../images/mbroker.png" alt="mbroker.png" />
</p>
</div>

<ul class="org-ul">
<li>RabitMQ is one of the most widely used message brokers, it acts as the
message broker, "the mailman", a microservice architecture needs.</li>
<li>RabbitMQ consists of:</li>
<li>producer - the client that create a message</li>
<li>consumer - receives a message</li>
<li>queue - stores messages</li>
<li>exchange - enables to route messages and send them to queues</li>
<li>The system functions in the following way:</li>
<li>producer creates a message and sends it to an exchange.</li>
<li>exchange receives a message and routes it to queues subscribed to it</li>
<li>consumer receives messages from those queues he/she is subscribed to.</li>
</ul>

<p>
Reference: <a href="https://medium.com/must-know-computer-science/system-design-message-queues-245612428a22">https://medium.com/must-know-computer-science/system-design-message-queues-245612428a22</a>
</p>
<hr />
<p>
A message queue is a form of asynchronous service-to-service communication
used in serverless and microservice architectures. Messages are stored on the
queue until they are processed and deleted. Each message is processed only
once, by a single consumer. Message queues can be used to decouple heavyweight
processing, to buffer or batch work, and to smooth spiky workloads.
</p>

<p>
In modern cloud architecture, applications are decoupled into smaller,
independent build blocks that are easier to develop, deploy and
maintain. Message queues provide communication for these distributed
applications. Message queues can significantly simplify coding of decoupled
applications, while improving performance, reliability and scalability.
</p>

<p>
Message queues allow different parts of a system to communicate and process
operations asynchronously. A message queue provides a lightweight buffer which
temporarily stores messages, and endpoints that allow software components to
connect to the queue in order to send and receive messages. The messages are
usually small, and can be things like requests, replies, error messages, or
just plain information. To send a message, a component called a producer adds
a message to the queue. The message is stored on the queue until another
component called a consumer retrieves the message and does something with it.
</p>


<div id="org2601aa3" class="figure">
<p><img src="../images/mq1.png" alt="mq1.png" />
</p>
</div>

<p>
Many producers and consumers can use the queue, but each message is processed
only once, by a single consumer. For this reason, this messaging pattern if
often called one-to-one, or point-to-point, communications. When a message
needs to be processed by more than one consumer, message queues can be
combined with Pub/Sub messaging in a fanout design pattern. See
<a href="https://aws.amazon.com/what-is/pub-sub-messaging/">https://aws.amazon.com/what-is/pub-sub-messaging/</a> for more details.
</p>
</div>
</div>
</div>
</body>
</html>
