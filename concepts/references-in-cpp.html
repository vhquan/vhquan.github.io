<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-08-18 Sun 11:39 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>References in C++</title>
<meta name="author" content="devlift" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="https://vhquan.github.io/css/style.css" type="text/css"/>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="/"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">References in C++</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgb73162c">1. Limitations of References</a></li>
<li><a href="#org59292cb">2. Advantages of using References</a></li>
<li><a href="#org81fecc8">3. When use?</a>
<ul>
<li><a href="#org543c6a2">3.1. References</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
When a variable is declared as a reference, it becomes an alternative namee
for an existing variable. A variable can be declared as a reference by putting
'&amp;' in the declaration.
</p>

<p>
<b>Syntax</b>:
<code>data_type &amp;ref = variable;</code>
</p>

<div id="outline-container-orgb73162c" class="outline-2">
<h2 id="orgb73162c"><span class="section-number-2">1.</span> Limitations of References</h2>
<div class="outline-text-2" id="text-1">
<ol class="org-ol">
<li>Once a reference is created, it cannot be later made to reference another
object; it cannot be reset. This is often done with pointers.</li>
<li>References cannot be NULL. Pointers are often made NULL to indicate that
they are not pointing to any valid thing.</li>
<li>A reference must be initialized when declared. There is no such restriction
with pointers.</li>
</ol>

<p>
Due to the above limitations, references in C++ cannot be used for
implementing data structures like Linked List, Tree, etc. 
</p>
</div>
</div>

<div id="outline-container-org59292cb" class="outline-2">
<h2 id="org59292cb"><span class="section-number-2">2.</span> Advantages of using References</h2>
<div class="outline-text-2" id="text-2">
<ol class="org-ol">
<li>Safer: Since reference must be initialized, wild references like wild
pointers are unlikely to exist. It is still possible to have references
that don't refer to a valid location.</li>
<li>Easier to use: References don't need a dereferencing operator to access the
value. They can be used like normal variables. The '&amp;' operator is needed
only at the time of declaration. Also, memebers of an object reference can
be accessed with the dot operator ('.'), unlike pointers where the arrow
operator (-&gt;) is needed to access members.</li>
</ol>
</div>
</div>
<div id="outline-container-org81fecc8" class="outline-2">
<h2 id="org81fecc8"><span class="section-number-2">3.</span> When use?</h2>
<div class="outline-text-2" id="text-3">
<p>
Use references wherever you can, and pointers wherever you must.
</p>

<p>
A void pointers until you can't.
</p>

<p>
The reason is that pointers make things harder to follow/read, less safe and
far more dangerous manipulations than any other constructs.
</p>

<p>
So the rule of thumb is to use pointers only if there is no other choice.
</p>

<p>
For example, returning a pointer to an object is a valid option when the
function can return <code>nullptr</code> in some cases and it is assumed it will. That
said, a better option would be to use something similar to <code>std::optional</code>
(requires C++17; before that, there's <code>boost::optional</code>).
</p>

<p>
Another example is to use pointers to raw memory for specific memory
manipulations. That should be hidden and localized in very narrow parts of the
code, to help limit the dangerous parts of the whole code base.
</p>

<p>
If the behaviour of the function would have to work with or without a given
object, then using a pointer as an attribute suggests that you can pass
<code>nullptr</code> as the argument and it is fine for the function. That's kind of a
contract between the user and the implemention.
</p>
</div>

<div id="outline-container-org543c6a2" class="outline-3">
<h3 id="org543c6a2"><span class="section-number-3">3.1.</span> References</h3>
<div class="outline-text-3" id="text-3-1">
<p>
<a href="https://www.geeksforgeeks.org/references-in-cpp/">https://www.geeksforgeeks.org/references-in-cpp/</a>
<a href="https://stackoverflow.com/questions/7058339/when-should-i-use-pointers-instead-of-references-in-api-design">https://stackoverflow.com/questions/7058339/when-should-i-use-pointers-instead-of-references-in-api-design</a>
<a href="https://www.geeksforgeeks.org/why-do-we-need-reference-variables-if-we-have-pointers/">https://www.geeksforgeeks.org/why-do-we-need-reference-variables-if-we-have-pointers/</a>
<a href="https://google.github.io/styleguide/cppguide.html">https://google.github.io/styleguide/cppguide.html</a>
<a href="https://www.geeksforgeeks.org/pointers-vs-references-cpp/">https://www.geeksforgeeks.org/pointers-vs-references-cpp/</a>
</p>
</div>
</div>
</div>
</div>
</body>
</html>
